#lang racket
(require racket/include rackunit rackunit/text-ui rackunit/gui)
(require "tree.rkt")

(test/gui
 (test-suite
  "Tests"
  (test-suite
   "tree?"
   (test-case "Empty tree" (check-true (tree? "*")))
   (test-case "Simple tree" (check-true (tree? "{5 * *}")))
   (test-case "Tree with spaces first" (check-true (tree? "      {5 * *}")))
   (test-case "Tree with spaces last" (check-true (tree? "{5 * *}       ")))
   (test-case "Simple tree without spaces" (check-true (tree? "{5**}")))
   (test-case "Tree with one child" (check-true (tree? "{5 {2 * *} *}")))
   (test-case "Tree with one child 2" (check-true (tree? "{5 * {2 * *}}")))
   (test-case "Complex tree" (check-true (tree? "{5 {2 {3 * {4 * *}} *} {6 {7 * * }*}}")))
   (test-case "Empty string" (check-false (tree? "")))
   (test-case "Tree with more than 2 childs" (check-false (tree? "{5 * * *}")))
   (test-case "Tree with number without opening bracket before him" (check-false (tree? "{5 * 3}")))
   (test-case "Complex false tree" (check-false (tree? "{5 {3 * *}{4 {6 * *} {8 * {9 * * *}}}}")))
   (test-case "Swapped brackets" (check-false (tree? "}5 * *{")))
   (test-case "More closing brackets" (check-false (tree? "{5 * {3 * *}}}}}}")))
   (test-case "Less closing brackets" (check-false (tree? "{5 * {3 * *}")))
   )
  (test-suite
   "string->tree"
   (test-case "Empty string to tree" (check-equal? (string->tree "*") '()))
   (test-case "Only root string to tree" (check-equal? (string->tree "{5 * *}") '(5 () ())))
   (test-case "Tree with spaces first" (check-equal? (string->tree "       {5 * *}") '(5 () ())))
   (test-case "Tree with spaces last" (check-equal? (string->tree "{5 * *}        ") '(5 () ())))
   (test-case "String with one child to tree" (check-equal? (string->tree "{5 * {1 * *}}") '(5 () (1 () ()))))
   (test-case "String with two childs to tree" (check-equal? (string->tree "{5 {1 * *} {2 * *}}") '(5 (1 () ()) (2 () ()))))
   (test-case "Complex tree" (check-equal? (string->tree "{5 {1 * *} {2 * {3 {4 {5 * *} * }* }}}") '(5 (1 () ()) (2 () (3 (4 (5 () ()) ()) ())))))
   (test-case "False string" (check-equal? (string->tree "{5 * * *}") #f))
  )
  (test-suite
   "balanced?"
   (test-case "Empty tree" (check-true (balanced? '())))
   (test-case "Only root" (check-true (balanced? '(5 () ()))))
   (test-case "One child" (check-true (balanced? '(5 (12 () ()) ()))))
   (test-case "Two childs" (check-true (balanced? '(5 (12 () ()) (16 () ())))))
   (test-case "One difference" (check-true (balanced? '(5 (12 () ()) (16 (1 () ()) ())))))
   (test-case "One difference with two childs" (check-true (balanced? '(5 (12 () ()) (16 (1 () ()) (2 () ()))))))
   (test-case "True complex" (check-true (balanced? '(5 (12 (11 () ()) ()) (16 (10 () ()) ())))))
   (test-case "Not balanced tree #1" (check-false (balanced? '(5 (12 (11 (10 () ()) ()) ()) (16 () ())))))
   (test-case "False with one difference" (check-false (balanced? '(5 (12 () ()) (16 (1 () ()) (2 (3 () ()) ()))))))
   (test-case "Not balanced tree #2" (check-false (balanced? '(5 (12 (11 () ()) (13 () ())) ()))))
   (test-case "With invalid tree" (check-false (balanced? '(5 () () ()))))
   )
  (test-suite
   "ordered?"
   (test-case "Empty tree" (check-true (ordered? '())))
   (test-case "Only root" (check-true (ordered? '(1 () ()))))
   (test-case "Only left child" (check-true (ordered? '(2 (1 () ()) ()))))
   (test-case "Only right child" (check-true (ordered? '(2 () (3 () ())))))
   (test-case "Simple tree" (check-true (ordered? '(2 (1 () ()) (3 () ())))))
   (test-case "Complex tree" (check-true (ordered? '(5 (4 (3 (2 (1 () ()) ()) ()) ()) (9 (8 () ()) (10 () (12 (11 () ()) (13 () ()))))))))
   (test-case "False with left child" (check-false (ordered? '(1 (2 () ()) ()))))
   (test-case "False with right child" (check-false (ordered? '(2 () (1 () ())))))
   (test-case "2 childs but only left false" (check-false (ordered? '(2 (4 () ()) (3 () ())))))
   (test-case "2 childs but only right false" (check-false (ordered? '(2 (1 () ()) (0 () ())))))
   (test-case "2 childs false" (check-false (ordered? '(2 (4 () ()) (1 () ())))))
   (test-case "Complex false right tree" (check-false (ordered? '(5 (4 (3 (2 (1 () ()) ()) ()) ()) (9 (8 () ()) (10 () (12 (11 () ()) (7 () ()))))))))
   (test-case "Complex false left tree" (check-false (ordered? '(5 (4 (3 (2 (7 () ()) ()) ()) ()) (9 (8 () ()) (10 () (12 (11 () ()) (13 () ()))))))))
   (test-case "With invalid tree" (check-false (ordered? '(5 () () ()))))
   )
  (test-suite
     "tree->string?"
     (test-case "Empty tree" (check-equal? (tree->string '()) "*"))
     (test-case "Only root" (check-equal? (tree->string '(1 () ())) "{1 * *}"))
     (test-case "Tree with left child" (check-equal? (tree->string '(1 (2 () ()) ())) "{1 {2 * *} *}"))
     (test-case "Tree with right child" (check-equal? (tree->string '(1 () (2 () ()))) "{1 * {2 * *}}"))
     (test-case "Complex tree 1" (check-equal? (tree->string '(1 (2 (3 () ()) ()) (4 (5 (6 () ()) ()) (7 () ())))) "{1 {2 {3 * *} *} {4 {5 {6 * *} *} {7 * *}}}"))
     (test-case "Complex tree 2 " (check-equal? (tree->string '(5 (4 (3 (2 (1 () ()) ()) ()) ()) (9 (8 () ()) (10 () (12 (11 () ()) (13 () ()))))))
                                             "{5 {4 {3 {2 {1 * *} *} *} *} {9 {8 * *} {10 * {12 {11 * *} {13 * *}}}}}"))
     (test-case "With invalid tree" (check-false (tree->string '(5 1 ()))))
     )
  (test-suite
   "tree->stream"
   (test-case "Empty tree inorder" (check-equal? (stream->list (tree->stream '() 'inorder)) '()))
   (test-case "Empty tree preorder" (check-equal? (stream->list (tree->stream '() 'preorder)) '()))
   (test-case "Empty tree postorder" (check-equal? (stream->list (tree->stream '() 'postorder)) '()))
   (test-case "Only root inorder" (check-equal? (stream->list (tree->stream '(5 () ()) 'inorder)) '(5)))
   (test-case "Only root preorder" (check-equal? (stream->list (tree->stream '(5 () ()) 'preorder)) '(5)))
   (test-case "Only root postorder" (check-equal? (stream->list (tree->stream '(5 () ()) 'postorder)) '(5)))
   (test-case "Tree with only left child inorder" (check-equal? (stream->list (tree->stream '(5 (1 () ()) ()) 'inorder)) '(1 5)))
   (test-case "Tree with only left child preorder" (check-equal? (stream->list (tree->stream '(5 (1 () ()) ()) 'preorder)) '(5 1)))
   (test-case "Tree with only left child postoreder" (check-equal? (stream->list (tree->stream '(5 (1 () ()) ()) 'postorder)) '(1 5)))
   (test-case "Tree with only right child inorder" (check-equal? (stream->list (tree->stream '(5 () (1 () ())) 'inorder)) '(5 1)))
   (test-case "Tree with only right child preorder" (check-equal? (stream->list (tree->stream '(5 () (1 () ())) 'preorder)) '(5 1)))
   (test-case "Tree with only right child postoreder" (check-equal? (stream->list (tree->stream '(5 () (1 () ())) 'postorder)) '(1 5)))
   (test-case "Simple tree inorder" (check-equal? (stream->list (tree->stream '(5 (1 () ()) (2 () ())) 'inorder)) '(1 5 2)))
   (test-case "Simple tree preorder" (check-equal? (stream->list (tree->stream '(5 (1 () ()) (2 () ())) 'preorder)) '(5 1 2)))
   (test-case "Simple tree postoreder" (check-equal? (stream->list (tree->stream '(5 (1 () ()) (2 () ())) 'postorder)) '(1 2 5)))
   (test-case "Complex tree inorder" (check-equal? (stream->list (tree->stream '(10 (15(2 () ()) (7 () ())) (5 (22 (2 () ()) (6 () ())) (1 () (3 (111 () ()) () )))) 'inorder))
                                                                 '(2 15 7 10 2 22 6 5 1 111 3)))
   (test-case "Complex tree preorder" (check-equal? (stream->list (tree->stream '(10 (15(2 () ()) (7 () ())) (5 (22 (2 () ()) (6 () ())) (1 () (3 (111 () ()) () )))) 'preorder))
                                                                 '(10 15 2 7 5 22 2 6 1 3 111)))
   (test-case "Complex tree postorder" (check-equal? (stream->list (tree->stream '(10 (15(2 () ()) (7 () ())) (5 (22 (2 () ()) (6 () ())) (1 () (3 (111 () ()) () )))) 'postorder))
                                                                 '(2 7 15 2 6 22 111 3 1 5 10)))
   (test-case "Wrong order" (check-false (tree->stream '() "test123")))

   )
  )
 )
 